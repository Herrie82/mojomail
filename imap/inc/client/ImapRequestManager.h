// @@@LICENSE
//
//      Copyright (c) 2010-2013 LG Electronics, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// LICENSE@@@

#ifndef IMAPREQUESTMANAGER_H_
#define IMAPREQUESTMANAGER_H_

#include "core/MojSignal.h"
#include <string>
#include <vector>
#include "protocol/ImapResponseParser.h"
#include "stream/LineReader.h"

class ImapSession;
class UntaggedUpdateParser;

/**
 * Manages sending requests to the IMAP server, and delegating responses to the appropriate
 * response handlers (ImapResponseParser instances).
 */
class ImapRequestManager : public MojSignalHandler
{
	struct PendingRequest
	{
		PendingRequest(const std::string& tag, const MojRefCountedPtr<ImapResponseParser>& parser, int timeout)
		: tag(tag), parser(parser), timeout(timeout) {}

		std::string tag;
		MojRefCountedPtr<ImapResponseParser> parser;
		int timeout;
	};

public:
	ImapRequestManager(ImapSession& session);
	virtual ~ImapRequestManager();
	
	/**
	 * Send a request with a timeout, and register a response handler.
	 *
	 * @param request			command to send to server (not including tag -- tag will be autogenerated)
	 * @param timeout			socket read timeout
	 * @param canLogRequest		whether it's safe to log this command (no sensitive data like passwords)
	 */
	void SendRequest(const std::string& request, const MojRefCountedPtr<ImapResponseParser>& responseParser, int timeout, bool canLogRequest);

	/**
	 * Switches to raw line reading mode. Used to read remainder of command after reading literal data.
	 * The next line received from the server will be passed directly to the parser instead of treating
	 * it as a response.
	 *
	 * @param responseParser	parser that will be called with extra lines
	 * @param timeoutSeconds	socket read timeout
	 */
	void RequestLine(const MojRefCountedPtr<ImapResponseParser>& responseParser, int timeoutSeconds = 0);

	/**
	 * Switches to raw data reading mode. Used for reading literal data.
	 * The upcoming N bytes (indicated by the bytes parameter) received from the server will be passed
	 * directly to the parser instead of treating it as a response.
	 *
	 * @param responseParser	parser that will be called with extra data
	 * @param bytes				number of bytes needed
	 * @param timeoutSeconds	socket read timeout
	 */
	void RequestData(const MojRefCountedPtr<ImapResponseParser>& responseParser, size_t bytes, int timeoutSeconds = 0);

	/**
	 * Change socket read timeout for a given request.
	 *
	 * @param responseParser	the parser to change the timeout for
	 */
	void UpdateRequestTimeout(const MojRefCountedPtr<ImapResponseParser>& responseParser, int timeoutSeconds);

	// TODO: make private?
	void WaitForParser(const MojRefCountedPtr<ImapResponseParser>& parser);

	/**
	 * Indicate that a parser is finished reading raw data. Returns to response parsing mode.
	 */
	void ParserFinished(const MojRefCountedPtr<ImapResponseParser>& parser);

	/**
	 * Cancel all requests
	 */
	void CancelRequests();

	void Status(MojObject& status);

	static MojLogger	s_protocolLog;

protected:
	std::string SendRequest(const std::string& request, bool canLogRequest);
	void WaitForResponses();
	
	// Returns true if we shouldn't process server responses right now
	bool Busy() const { return m_handlingResponses || m_waitingForLine || m_currentParser.get(); }

	MojErr HandleResponses();
	void HandleResponseLine(const std::string& line);
	
	MojErr HandleMoreData();

	void HandleGenericUntaggedResponse(const std::string& line);

	void ReportException(const std::exception& e);
	void Reset();

	int GetNextTimeout();

	ImapSession&	m_session;
	MojLogger&		m_log;

	int				m_currentRequestId;

	// Whether we're currently inside HandleResponses()
	bool			m_handlingResponses;

	// Whether we're already waiting for more data from the server
	bool			m_waitingForLine;

	// Parser which currently has control over the LineReader
	MojRefCountedPtr<ImapResponseParser>	m_currentParser;

	// Parser which currently has control over the LineReader
	MojRefCountedPtr<UntaggedUpdateParser>	m_untaggedUpdateParser;

	std::vector<PendingRequest>		m_pendingRequests;

	LineReader::LineAvailableSignal::Slot<ImapRequestManager>	m_handleResponsesSlot;
	LineReader::LineAvailableSignal::Slot<ImapRequestManager>	m_handleMoreDataSlot;
};

#endif /*IMAPREQUESTMANAGER_H_*/
